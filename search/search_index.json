{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Certainly! Here's a paraphrased version of the entire task while preserving all technical content and meanings , and not altering the equations or conclusions : Problem 1 1-1. Theoretical Derivation The motion of a projectile can be described using Newton's second law. When air resistance is neglected, the kinematic equations govern the system: Horizontal motion: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] (This is uniform motion as there is no horizontal acceleration.) Vertical motion: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] (Gravity acts downward, causing vertical acceleration.) To compute the range \\(R\\) , determine the time when the projectile returns to the ground by setting \\(y(t) = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute this into the horizontal position equation: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , the range formula becomes: \\[ R = \\frac{v_0^2}{g} \\sin(2\\theta) \\] 1-2. Theoretical Analysis of the Range Equations of Motion Projectile motion without air resistance can be modeled as: Horizontal displacement: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical displacement: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Where: \\(v_0\\) is the initial speed, \\(\\theta\\) is the launch angle, \\(g\\) is gravitational acceleration. Time of Flight To find how long the projectile stays airborne, solve \\(y(t) = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range Equation Insert \\(t_f\\) into the horizontal equation: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Applying the identity again gives: \\[ R = \\frac{v_0^2}{g} \\sin(2\\theta) \\] Analysis & Observations The maximum range is achieved at a 45\u00b0 launch angle. The range is symmetric around 45\u00b0, meaning 30\u00b0 and 60\u00b0 yield the same result. Increasing \\(v_0\\) leads to a larger range. Higher \\(g\\) values reduce the range. Limitation: Air resistance is not accounted for, which would reduce the ideal launch angle slightly below 45\u00b0 in real situations. 1-3. Key Equations of Projectile Motion 1. Equations of Motion When a projectile is launched with an initial velocity \\(v_0\\) at angle \\(\\theta\\) : Horizontal: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] 2. Flight Time Find when the projectile hits the ground by setting \\(y = 0\\) : \\[ t_\\text{flight} = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 3. Maximum Height Occurs when vertical velocity becomes zero: \\[ h_\\text{max} = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] 4. Range Horizontal distance covered: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1-4. Project Summary: Simulation & Analysis of Projectile Motion Motivation: Projectile motion is a foundational topic in physics, illustrating the effects of angle and velocity on a body\u2019s trajectory. While simple, it reveals principles relevant to many fields, such as ballistics or sports. Objective: Create a computational model that simulates projectile motion and visualizes how the range varies with launch angle, taking into account variables like velocity, gravity, and height. Implementation Strategy: Mathematical Framework: Horizontal motion: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Where: \\(v_0\\) = initial speed \\(\\theta\\) = launch angle \\(g\\) = gravitational acceleration Computational Model: Use Python , leveraging NumPy for numerical calculations and Matplotlib for plotting. Simulation Tasks: Calculate the range for varying launch angles. Plot range vs. angle graphs under different initial speeds and conditions. Adjust gravity and initial height to observe their effects. Visual Outputs: Range vs. angle plots for multiple velocities. Visualization of optimal launch angles depending on speed. Evaluation: Analyze how different parameters affect motion and range. Determine the angle that maximizes range in various scenarios. Model Assumptions: This simulation assumes: No air resistance Constant gravitational field Flat ground level Future Considerations: Examine how resistance, wind, and launch height alter trajectories. Suggest improvements for modeling more realistic conditions. Let me know if you need this translated into another language or turned into a report/document format.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-1-theoretical-derivation","text":"The motion of a projectile can be described using Newton's second law. When air resistance is neglected, the kinematic equations govern the system: Horizontal motion: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] (This is uniform motion as there is no horizontal acceleration.) Vertical motion: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] (Gravity acts downward, causing vertical acceleration.) To compute the range \\(R\\) , determine the time when the projectile returns to the ground by setting \\(y(t) = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute this into the horizontal position equation: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , the range formula becomes: \\[ R = \\frac{v_0^2}{g} \\sin(2\\theta) \\]","title":"1-1. Theoretical Derivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-2-theoretical-analysis-of-the-range","text":"Equations of Motion Projectile motion without air resistance can be modeled as: Horizontal displacement: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical displacement: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Where: \\(v_0\\) is the initial speed, \\(\\theta\\) is the launch angle, \\(g\\) is gravitational acceleration. Time of Flight To find how long the projectile stays airborne, solve \\(y(t) = 0\\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range Equation Insert \\(t_f\\) into the horizontal equation: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Applying the identity again gives: \\[ R = \\frac{v_0^2}{g} \\sin(2\\theta) \\] Analysis & Observations The maximum range is achieved at a 45\u00b0 launch angle. The range is symmetric around 45\u00b0, meaning 30\u00b0 and 60\u00b0 yield the same result. Increasing \\(v_0\\) leads to a larger range. Higher \\(g\\) values reduce the range. Limitation: Air resistance is not accounted for, which would reduce the ideal launch angle slightly below 45\u00b0 in real situations.","title":"1-2. Theoretical Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-3-key-equations-of-projectile-motion","text":"1. Equations of Motion When a projectile is launched with an initial velocity \\(v_0\\) at angle \\(\\theta\\) : Horizontal: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] 2. Flight Time Find when the projectile hits the ground by setting \\(y = 0\\) : \\[ t_\\text{flight} = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 3. Maximum Height Occurs when vertical velocity becomes zero: \\[ h_\\text{max} = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] 4. Range Horizontal distance covered: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1-3. Key Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-4-project-summary-simulation-analysis-of-projectile-motion","text":"Motivation: Projectile motion is a foundational topic in physics, illustrating the effects of angle and velocity on a body\u2019s trajectory. While simple, it reveals principles relevant to many fields, such as ballistics or sports. Objective: Create a computational model that simulates projectile motion and visualizes how the range varies with launch angle, taking into account variables like velocity, gravity, and height. Implementation Strategy: Mathematical Framework: Horizontal motion: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Where: \\(v_0\\) = initial speed \\(\\theta\\) = launch angle \\(g\\) = gravitational acceleration Computational Model: Use Python , leveraging NumPy for numerical calculations and Matplotlib for plotting. Simulation Tasks: Calculate the range for varying launch angles. Plot range vs. angle graphs under different initial speeds and conditions. Adjust gravity and initial height to observe their effects. Visual Outputs: Range vs. angle plots for multiple velocities. Visualization of optimal launch angles depending on speed. Evaluation: Analyze how different parameters affect motion and range. Determine the angle that maximizes range in various scenarios. Model Assumptions: This simulation assumes: No air resistance Constant gravitational field Flat ground level Future Considerations: Examine how resistance, wind, and launch height alter trajectories. Suggest improvements for modeling more realistic conditions. Let me know if you need this translated into another language or turned into a report/document format.","title":"1-4. Project Summary: Simulation &amp; Analysis of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Certainly! Here's the professionally rewritten and organized version of your Forced Damped Pendulum project in English: \ud83c\udf93 2-1-1 Theoretical Foundation \ud83e\udde0 Governing Differential Equation The forced damped pendulum is described by the following nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \u03b8(t): Angular displacement \u03b3: Damping coefficient \u03c9\u2080 = \u221a(g/L): Natural angular frequency A: Amplitude of the external driving force \u03c9: Frequency of the external driving force --- f s \ud83d\udd0d Small-Angle Approximation For small angles (\u03b8 < 0.2 rad): \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation to a linear form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] \u2705 Analytical Solution The general solution of this second-order linear non-homogeneous ODE is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] \ud83d\udcd8 Homogeneous (Transient) Solution: \\[ \\theta_{\\text{hom}}(t) = C_1 e^{-\\gamma t/2} \\cos(\\omega_d t) + C_2 e^{-\\gamma t/2} \\sin(\\omega_d t) \\] Where: \\[ \\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\] \ud83d\udcd8 Particular (Steady-State) Solution: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\phi) \\] With: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}}, \\quad \\tan(\\phi) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\] \ud83c\udfaf Resonance Condition Resonance occurs when the amplitude is maximized, i.e., when the denominator of \\(B\\) is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - 2\\gamma^2} \\] \ud83d\udcca 2-1-2 Dynamics Analysis Summary The system\u2019s behavior depends on three key parameters: Damping (\u03b3): Low damping \u2192 Sustained oscillations and sharp resonance High damping \u2192 Suppressed motion and reduced resonance Driving Amplitude (A): Small A \u2192 Regular periodic motion Large A \u2192 Complex or chaotic behavior Driving Frequency (\u03c9): Near \u03c9\u2080 \u2192 Resonance and large amplitude Far from \u03c9\u2080 \u2192 Periodic, quasiperiodic, or chaotic behavior As parameters vary, the system may transition from simple harmonic motion to chaos, often via period doubling . These behaviors are best visualized using time series , phase portraits , and Poincar\u00e9 sections . \ud83c\udf0d 2-1-3 Real-World Applications Energy Harvesting Devices: Pendulum models help design systems that harvest mechanical vibrations efficiently under periodic driving. Suspension Bridges: Forced oscillations under wind or traffic loads must be analyzed to prevent resonance-induced failures. RLC Circuits: Analogous behavior in electrical circuits makes this model useful for analyzing damping and resonance in electronics. Biomechanics (Human Gait): Useful for understanding walking dynamics and designing prosthetics or studying movement disorders. \ud83d\udee0\ufe0f 2-1-4 Simulation and Visualization \ud83c\udfaf Objective This section focuses on advanced simulation of the forced damped pendulum, including: Bifurcation Diagrams to track how system behavior changes with varying parameters Poincar\u00e9 Sections to reveal the underlying structure of chaotic motion Phase Portraits to visualize trajectories in phase space \ud83d\udd2c Tools \ud83d\udcc8 Bifurcation Diagram: Visualizes how long-term system behavior evolves as a parameter (typically A) is varied. It reveals the route to chaos via period doubling. \ud83d\udd01 Poincar\u00e9 Section: Samples the system state at regular intervals (e.g., each period of driving force). Helps identify periodic , quasiperiodic , or chaotic regimes. \ud83c\udf0c Phase Portrait: Plots angular velocity \\(\\dot{\\theta}\\) versus angular displacement \u03b8 to observe system evolution: Limit cycles \u2192 regular oscillation Strange attractors \u2192 chaotic motion","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-1-1-theoretical-foundation","text":"","title":"\ud83c\udf93 2-1-1 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The forced damped pendulum is described by the following nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \u03b8(t): Angular displacement \u03b3: Damping coefficient \u03c9\u2080 = \u221a(g/L): Natural angular frequency A: Amplitude of the external driving force \u03c9: Frequency of the external driving force --- f s","title":"\ud83e\udde0 Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles (\u03b8 < 0.2 rad): \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation to a linear form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\]","title":"\ud83d\udd0d Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analytical-solution","text":"The general solution of this second-order linear non-homogeneous ODE is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\]","title":"\u2705 Analytical Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-transient-solution","text":"\\[ \\theta_{\\text{hom}}(t) = C_1 e^{-\\gamma t/2} \\cos(\\omega_d t) + C_2 e^{-\\gamma t/2} \\sin(\\omega_d t) \\] Where: \\[ \\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\]","title":"\ud83d\udcd8 Homogeneous (Transient) Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-steady-state-solution","text":"\\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\phi) \\] With: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}}, \\quad \\tan(\\phi) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\]","title":"\ud83d\udcd8 Particular (Steady-State) Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the amplitude is maximized, i.e., when the denominator of \\(B\\) is minimized: \\[ \\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - 2\\gamma^2} \\]","title":"\ud83c\udfaf Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-1-2-dynamics-analysis-summary","text":"The system\u2019s behavior depends on three key parameters: Damping (\u03b3): Low damping \u2192 Sustained oscillations and sharp resonance High damping \u2192 Suppressed motion and reduced resonance Driving Amplitude (A): Small A \u2192 Regular periodic motion Large A \u2192 Complex or chaotic behavior Driving Frequency (\u03c9): Near \u03c9\u2080 \u2192 Resonance and large amplitude Far from \u03c9\u2080 \u2192 Periodic, quasiperiodic, or chaotic behavior As parameters vary, the system may transition from simple harmonic motion to chaos, often via period doubling . These behaviors are best visualized using time series , phase portraits , and Poincar\u00e9 sections .","title":"\ud83d\udcca 2-1-2 Dynamics Analysis Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-1-3-real-world-applications","text":"Energy Harvesting Devices: Pendulum models help design systems that harvest mechanical vibrations efficiently under periodic driving. Suspension Bridges: Forced oscillations under wind or traffic loads must be analyzed to prevent resonance-induced failures. RLC Circuits: Analogous behavior in electrical circuits makes this model useful for analyzing damping and resonance in electronics. Biomechanics (Human Gait): Useful for understanding walking dynamics and designing prosthetics or studying movement disorders.","title":"\ud83c\udf0d 2-1-3 Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-1-4-simulation-and-visualization","text":"","title":"\ud83d\udee0\ufe0f 2-1-4 Simulation and Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#objective","text":"This section focuses on advanced simulation of the forced damped pendulum, including: Bifurcation Diagrams to track how system behavior changes with varying parameters Poincar\u00e9 Sections to reveal the underlying structure of chaotic motion Phase Portraits to visualize trajectories in phase space","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#tools","text":"","title":"\ud83d\udd2c Tools"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram","text":"Visualizes how long-term system behavior evolves as a parameter (typically A) is varied. It reveals the route to chaos via period doubling.","title":"\ud83d\udcc8 Bifurcation Diagram:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"Samples the system state at regular intervals (e.g., each period of driving force). Helps identify periodic , quasiperiodic , or chaotic regimes.","title":"\ud83d\udd01 Poincar\u00e9 Section:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portrait","text":"Plots angular velocity \\(\\dot{\\theta}\\) versus angular displacement \u03b8 to observe system evolution: Limit cycles \u2192 regular oscillation Strange attractors \u2192 chaotic motion","title":"\ud83c\udf0c Phase Portrait:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"\ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius \ud83d\udd22 Task 1: Derive the relationship between orbital period and radius \ud83d\udd2c Theoretical Background From Newton\u2019s Law of Gravitation and centripetal force for circular orbits: \\[ F_g = \\frac{G M m}{r^2}, \\quad F_c = \\frac{m v^2}{r} \\] Equating both: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity: \\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substitute \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\Rightarrow \\boxed{T^2 \\propto r^3} \\] \ud83d\udcbb Python Code \u2013 Kepler\u2019s Law Formula Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Define orbital radius range (m) radii = np.linspace(7e6, 4.2e7, 100) # Calculate orbital period using the derived formula T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot period vs radius^1.5 to show linearity plt.figure(figsize=(7,5)) plt.plot(radii**1.5, T, color='blue') plt.xlabel(\"$r^{1.5}$ [m$^{1.5}$]\") plt.ylabel(\"Orbital Period $T$ [s]\") plt.title(\"Verification of $T \\\\propto r^{1.5}$ (Kepler\u2019s 3rd Law)\") plt.grid(True) plt.tight_layout() plt.show() \ud83d\udef0\ufe0f Task 2: Implications for Astronomy \ud83c\udf0c Explanation Kepler's Third Law is fundamental for understanding how celestial bodies move and interact. It allows astronomers to: \ud83e\ude90 Determine masses of planets and stars by observing satellite orbits. \ud83c\udf0d Estimate distances in solar and extrasolar systems. \ud83d\udef0\ufe0f Design satellite orbits (e.g. GPS, geostationary satellites). \ud83d\udd2d Detect exoplanets by measuring how a star wobbles due to an unseen companion. \ud83d\udcbb Python Code \u2013 Mass Estimation from Orbital Data Example: Estimate Earth's mass from Moon\u2019s orbit. # Moon data T_moon = 27.3 * 24 * 3600 # seconds r_moon = 3.84e8 # meters # Rearranged formula: M = 4\u03c0\u00b2r\u00b3 / (GT\u00b2) M_earth_est = 4 * np.pi**2 * r_moon**3 / (G * T_moon**2) print(f\"Estimated Earth mass: {M_earth_est:.2e} kg\") \ud83c\udf0d Task 3: Analyze Real-World Examples \ud83d\udccc Examples Moon orbiting Earth \\(r = 3.84 \\times 10^8 \\, \\text{m}, \\; T = 27.3 \\, \\text{days}\\) From this, Earth's mass can be estimated accurately. Earth orbiting Sun \\(r = 1.496 \\times 10^{11} \\, \\text{m}, \\; T = 365.25 \\, \\text{days}\\) Useful for measuring astronomical units (AU). Mars vs Jupiter Jupiter\u2019s orbital period is \u224811.9 years, and its distance is much greater \u2014 validating \\(T^2 \\propto r^3\\) . \ud83d\udcbb Python Code \u2013 Compare Planets (Simplified) # Orbital data for planets (AU and years) r_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58]) # Mercury to Saturn T_years = np.array([0.24, 0.61, 1.0, 1.88, 11.86, 29.45]) # Convert to SI r_m = r_AU * 1.496e11 T_s = T_years * 365.25 * 24 * 3600 # Check T\u00b2 vs r\u00b3 plt.figure(figsize=(7,5)) plt.plot(r_m**3, T_s**2, 'o-', color='green') plt.xlabel(\"$r^3$ [m\u00b3]\") plt.ylabel(\"$T^2$ [s\u00b2]\") plt.title(\"Solar System: $T^2$ vs $r^3$\") plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcbb Task 4: Implement Simulation & Extend to Elliptical Orbits \ud83e\uddea Simulation of Circular Orbits Already shown above \u2014 the code verifies \\(T^2 \\propto r^3\\) with circular orbits around Earth and Sun. \ud83d\udfe3 Elliptical Orbits: Generalization For elliptical orbits , Kepler\u2019s Law still applies: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis . This generalization allows the same method to work for: Planets with eccentric orbits (e.g. Pluto) Comets like Halley\u2019s comet Binary star systems \ud83d\udcbb Optional Code \u2013 Elliptical Orbit Plot (2D) # Sample elliptical orbit a = 1.5e11 # semi-major axis e = 0.6 # eccentricity theta = np.linspace(0, 2*np.pi, 1000) r = (a * (1 - e**2)) / (1 + e * np.cos(theta)) # Convert to Cartesian x = r * np.cos(theta) y = r * np.sin(theta) plt.figure(figsize=(6,6)) plt.plot(x, y, label=f\"e={e}\") plt.plot([0], [0], 'yo', label=\"Focus (Sun)\") plt.title(\"Elliptical Orbit\") plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() \u2705 Summary Task Covered 1. Derivation of Kepler\u2019s Law \u2714\ufe0f 2. Implications in Astronomy \u2714\ufe0f 3. Real-World Examples \u2714\ufe0f 4. Computational Model + Elliptical Case \u2714\ufe0f","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"\ud83d\udcd8 Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-1-derive-the-relationship-between-orbital-period-and-radius","text":"","title":"\ud83d\udd22 Task 1: Derive the relationship between orbital period and radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"From Newton\u2019s Law of Gravitation and centripetal force for circular orbits: \\[ F_g = \\frac{G M m}{r^2}, \\quad F_c = \\frac{m v^2}{r} \\] Equating both: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is related to velocity: \\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} \\] Substitute \\(v^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\Rightarrow \\boxed{T^2 \\propto r^3} \\]","title":"\ud83d\udd2c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-keplers-law-formula-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Define orbital radius range (m) radii = np.linspace(7e6, 4.2e7, 100) # Calculate orbital period using the derived formula T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plot period vs radius^1.5 to show linearity plt.figure(figsize=(7,5)) plt.plot(radii**1.5, T, color='blue') plt.xlabel(\"$r^{1.5}$ [m$^{1.5}$]\") plt.ylabel(\"Orbital Period $T$ [s]\") plt.title(\"Verification of $T \\\\propto r^{1.5}$ (Kepler\u2019s 3rd Law)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Python Code \u2013 Kepler\u2019s Law Formula Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-2-implications-for-astronomy","text":"","title":"\ud83d\udef0\ufe0f Task 2: Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation","text":"Kepler's Third Law is fundamental for understanding how celestial bodies move and interact. It allows astronomers to: \ud83e\ude90 Determine masses of planets and stars by observing satellite orbits. \ud83c\udf0d Estimate distances in solar and extrasolar systems. \ud83d\udef0\ufe0f Design satellite orbits (e.g. GPS, geostationary satellites). \ud83d\udd2d Detect exoplanets by measuring how a star wobbles due to an unseen companion.","title":"\ud83c\udf0c Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-mass-estimation-from-orbital-data","text":"Example: Estimate Earth's mass from Moon\u2019s orbit. # Moon data T_moon = 27.3 * 24 * 3600 # seconds r_moon = 3.84e8 # meters # Rearranged formula: M = 4\u03c0\u00b2r\u00b3 / (GT\u00b2) M_earth_est = 4 * np.pi**2 * r_moon**3 / (G * T_moon**2) print(f\"Estimated Earth mass: {M_earth_est:.2e} kg\")","title":"\ud83d\udcbb Python Code \u2013 Mass Estimation from Orbital Data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-3-analyze-real-world-examples","text":"","title":"\ud83c\udf0d Task 3: Analyze Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#examples","text":"Moon orbiting Earth \\(r = 3.84 \\times 10^8 \\, \\text{m}, \\; T = 27.3 \\, \\text{days}\\) From this, Earth's mass can be estimated accurately. Earth orbiting Sun \\(r = 1.496 \\times 10^{11} \\, \\text{m}, \\; T = 365.25 \\, \\text{days}\\) Useful for measuring astronomical units (AU). Mars vs Jupiter Jupiter\u2019s orbital period is \u224811.9 years, and its distance is much greater \u2014 validating \\(T^2 \\propto r^3\\) .","title":"\ud83d\udccc Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-compare-planets-simplified","text":"# Orbital data for planets (AU and years) r_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58]) # Mercury to Saturn T_years = np.array([0.24, 0.61, 1.0, 1.88, 11.86, 29.45]) # Convert to SI r_m = r_AU * 1.496e11 T_s = T_years * 365.25 * 24 * 3600 # Check T\u00b2 vs r\u00b3 plt.figure(figsize=(7,5)) plt.plot(r_m**3, T_s**2, 'o-', color='green') plt.xlabel(\"$r^3$ [m\u00b3]\") plt.ylabel(\"$T^2$ [s\u00b2]\") plt.title(\"Solar System: $T^2$ vs $r^3$\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Python Code \u2013 Compare Planets (Simplified)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-4-implement-simulation-extend-to-elliptical-orbits","text":"","title":"\ud83d\udcbb Task 4: Implement Simulation &amp; Extend to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-of-circular-orbits","text":"Already shown above \u2014 the code verifies \\(T^2 \\propto r^3\\) with circular orbits around Earth and Sun.","title":"\ud83e\uddea Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#elliptical-orbits-generalization","text":"For elliptical orbits , Kepler\u2019s Law still applies: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis . This generalization allows the same method to work for: Planets with eccentric orbits (e.g. Pluto) Comets like Halley\u2019s comet Binary star systems","title":"\ud83d\udfe3 Elliptical Orbits: Generalization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#optional-code-elliptical-orbit-plot-2d","text":"# Sample elliptical orbit a = 1.5e11 # semi-major axis e = 0.6 # eccentricity theta = np.linspace(0, 2*np.pi, 1000) r = (a * (1 - e**2)) / (1 + e * np.cos(theta)) # Convert to Cartesian x = r * np.cos(theta) y = r * np.sin(theta) plt.figure(figsize=(6,6)) plt.plot(x, y, label=f\"e={e}\") plt.plot([0], [0], 'yo', label=\"Focus (Sun)\") plt.title(\"Elliptical Orbit\") plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcbb Optional Code \u2013 Elliptical Orbit Plot (2D)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Task Covered 1. Derivation of Kepler\u2019s Law \u2714\ufe0f 2. Implications in Astronomy \u2714\ufe0f 3. Real-World Examples \u2714\ufe0f 4. Computational Model + Elliptical Case \u2714\ufe0f","title":"\u2705 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities \ud83e\udde0 Task 1: Define the first, second, and third cosmic velocities \ud83d\udd39 First Cosmic Velocity (Orbital Velocity) Definition : The minimum speed required to enter a stable circular orbit around a celestial body just above its surface. Formula : \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] \ud83d\udd39 Second Cosmic Velocity (Escape Velocity) Definition : The minimum speed needed to escape a celestial body\u2019s gravitational field entirely, without further propulsion. Formula : \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\] \ud83d\udd39 Third Cosmic Velocity (Interstellar Escape) Definition : The velocity needed to escape the gravitational pull of a planetary system (e.g., the Sun). Approximation : \\[ v_3 = \\sqrt{v_{esc\\_planet}^2 + v_{esc\\_sun}^2} \\] \ud83d\udcd0 Task 2: Mathematical Derivations and Parameters \u2705 Escape Velocity Derivation From conservation of energy: \\[ \\text{Kinetic Energy} = \\text{Gravitational Potential Energy} \\\\ \\frac{1}{2} m v^2 = \\frac{G M m}{r} \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the celestial body \\(r\\) : Radius (distance from center of mass) \ud83d\udcbb Python Code \u2013 Derivation Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 # Function to calculate velocities def compute_cosmic_velocities(M, r): v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) return v1, v2 # Earth values M_earth = 5.972e24 # kg r_earth = 6.371e6 # m v1_earth, v2_earth = compute_cosmic_velocities(M_earth, r_earth) print(f\"Earth: v1 = {v1_earth:.2f} m/s, v2 = {v2_earth:.2f} m/s\") \ud83c\udf0d Task 3: Compute for Earth, Mars, and Jupiter \ud83d\udca1 Celestial Data # Celestial data (mass in kg, radius in m) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } # Calculate velocities results = {} for body, (M, r) in bodies.items(): v1, v2 = compute_cosmic_velocities(M, r) results[body] = (v1, v2) print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s\") \ud83d\udcca Visualization labels = list(results.keys()) v1_vals = [results[b][0] for b in labels] v2_vals = [results[b][1] for b in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(8,5)) plt.bar(x - width/2, [v/1000 for v in v1_vals], width, label='1st Cosmic (v1)') plt.bar(x + width/2, [v/1000 for v in v2_vals], width, label='2nd Cosmic (v2)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities of Planets') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udef0\ufe0f Task 4: Importance in Space Exploration \ud83d\ude80 Applications: First Cosmic Velocity : Used to launch satellites into orbit. Second Cosmic Velocity : Required for lunar and interplanetary missions. Third Cosmic Velocity : Enables spacecraft to escape the Solar System (e.g., Voyager missions). \ud83d\udef8 Summary Table Cosmic Velocity Use Case Example 1st (v1) Orbiting a planet Satellite, ISS 2nd (v2) Escaping a planet Mars rover, Moon mission 3rd (v3) Leaving a planetary system Voyager 1 & 2, New Horizons Understanding these velocities ensures efficient fuel usage, mission planning, and reaching new frontiers in space exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-1-define-the-first-second-and-third-cosmic-velocities","text":"","title":"\ud83e\udde0 Task 1: Define the first, second, and third cosmic velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum speed required to enter a stable circular orbit around a celestial body just above its surface. Formula : \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"\ud83d\udd39 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : The minimum speed needed to escape a celestial body\u2019s gravitational field entirely, without further propulsion. Formula : \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"\ud83d\udd39 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"Definition : The velocity needed to escape the gravitational pull of a planetary system (e.g., the Sun). Approximation : \\[ v_3 = \\sqrt{v_{esc\\_planet}^2 + v_{esc\\_sun}^2} \\]","title":"\ud83d\udd39 Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-2-mathematical-derivations-and-parameters","text":"","title":"\ud83d\udcd0 Task 2: Mathematical Derivations and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-derivation","text":"From conservation of energy: \\[ \\text{Kinetic Energy} = \\text{Gravitational Potential Energy} \\\\ \\frac{1}{2} m v^2 = \\frac{G M m}{r} \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the celestial body \\(r\\) : Radius (distance from center of mass)","title":"\u2705 Escape Velocity Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-derivation-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 # Function to calculate velocities def compute_cosmic_velocities(M, r): v1 = np.sqrt(G * M / r) v2 = np.sqrt(2 * G * M / r) return v1, v2 # Earth values M_earth = 5.972e24 # kg r_earth = 6.371e6 # m v1_earth, v2_earth = compute_cosmic_velocities(M_earth, r_earth) print(f\"Earth: v1 = {v1_earth:.2f} m/s, v2 = {v2_earth:.2f} m/s\")","title":"\ud83d\udcbb Python Code \u2013 Derivation Verification"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-3-compute-for-earth-mars-and-jupiter","text":"","title":"\ud83c\udf0d Task 3: Compute for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-data","text":"# Celestial data (mass in kg, radius in m) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } # Calculate velocities results = {} for body, (M, r) in bodies.items(): v1, v2 = compute_cosmic_velocities(M, r) results[body] = (v1, v2) print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s\")","title":"\ud83d\udca1 Celestial Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization","text":"labels = list(results.keys()) v1_vals = [results[b][0] for b in labels] v2_vals = [results[b][1] for b in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(8,5)) plt.bar(x - width/2, [v/1000 for v in v1_vals], width, label='1st Cosmic (v1)') plt.bar(x + width/2, [v/1000 for v in v2_vals], width, label='2nd Cosmic (v2)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities of Planets') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcca Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-4-importance-in-space-exploration","text":"","title":"\ud83d\udef0\ufe0f Task 4: Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications","text":"First Cosmic Velocity : Used to launch satellites into orbit. Second Cosmic Velocity : Required for lunar and interplanetary missions. Third Cosmic Velocity : Enables spacecraft to escape the Solar System (e.g., Voyager missions).","title":"\ud83d\ude80 Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-table","text":"Cosmic Velocity Use Case Example 1st (v1) Orbiting a planet Satellite, ISS 2nd (v2) Escaping a planet Mars rover, Moon mission 3rd (v3) Leaving a planetary system Voyager 1 & 2, New Horizons Understanding these velocities ensures efficient fuel usage, mission planning, and reaching new frontiers in space exploration.","title":"\ud83d\udef8 Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Problem 4: Interference Patterns on a Water Surface \ud83c\udfaf Task 1: Define the Physical Setup \ud83d\udd37 Regular Polygon and Source Placement We consider a regular polygon\u2014e.g., an equilateral triangle \u2014with point sources placed at its vertices on a water surface. Each point emits circular waves with the same amplitude, frequency, and wavelength. \ud83d\udcd0 Task 2: Mathematical Formulation of Waves \ud83e\uddee Single Wave Expression A circular wave from a point source at position $(x_s, y_s)$ is described as: \\[ \\eta(x, y, t) = A \\cos(k r - \\omega t + \\phi) \\] Where: $\\eta(x, y, t)$ is the surface displacement $A$ is amplitude $k = \\frac{2\\pi}{\\lambda}$ is the wave number $\\omega = 2\\pi f$ is the angular frequency $r = \\sqrt{(x - x_s)^2 + (y - y_s)^2}$ is the distance to the source $\\phi$ is the phase (set to 0 for simplicity) \ud83e\uddee Total Interference (Superposition Principle) For $N$ point sources at $(x_i, y_i)$: \\[ \\eta_{total}(x, y, t) = \\sum_{i=1}^N A \\cos(k r_i - \\omega t) \\] Where $r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}$ is the distance from point $(x, y)$ to source $i$. \ud83d\udc0d Task 3: Python Simulation \u2013 Visualizing Interference import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude wavelength = 1.0 # Wavelength (meters) freq = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength omega = 2 * np.pi * freq def generate_polygon(n_sides, radius=2.0): angles = np.linspace(0, 2*np.pi, n_sides, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Polygon source points sources = generate_polygon(3) # Triangle # Time snapshot t = 0 eta_total = np.zeros_like(X) for (x_s, y_s) in sources: R = np.sqrt((X - x_s)**2 + (Y - y_s)**2) eta_total += A * np.cos(k * R - omega * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Wave Displacement') plt.title('Water Surface Interference Pattern (Equilateral Triangle Sources)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() \ud83e\udded Task 4: Interpretation and Applications \ud83d\udd0d Interference Analysis Constructive Interference : Peaks where wave crests meet Destructive Interference : Nulls where crest meets trough Fringe Patterns : Formed based on polygon geometry and wavelength \ud83c\udf10 Applications Sound systems (phase control) Water wave tanks (research and education) Optics (laser interference from multiple slits) Antenna arrays","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-4-interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Problem 4: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-1-define-the-physical-setup","text":"","title":"\ud83c\udfaf Task 1: Define the Physical Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#regular-polygon-and-source-placement","text":"We consider a regular polygon\u2014e.g., an equilateral triangle \u2014with point sources placed at its vertices on a water surface. Each point emits circular waves with the same amplitude, frequency, and wavelength.","title":"\ud83d\udd37 Regular Polygon and Source Placement"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-2-mathematical-formulation-of-waves","text":"","title":"\ud83d\udcd0 Task 2: Mathematical Formulation of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-wave-expression","text":"A circular wave from a point source at position $(x_s, y_s)$ is described as: \\[ \\eta(x, y, t) = A \\cos(k r - \\omega t + \\phi) \\] Where: $\\eta(x, y, t)$ is the surface displacement $A$ is amplitude $k = \\frac{2\\pi}{\\lambda}$ is the wave number $\\omega = 2\\pi f$ is the angular frequency $r = \\sqrt{(x - x_s)^2 + (y - y_s)^2}$ is the distance to the source $\\phi$ is the phase (set to 0 for simplicity)","title":"\ud83e\uddee Single Wave Expression"},{"location":"1%20Physics/3%20Waves/Problem_1/#total-interference-superposition-principle","text":"For $N$ point sources at $(x_i, y_i)$: \\[ \\eta_{total}(x, y, t) = \\sum_{i=1}^N A \\cos(k r_i - \\omega t) \\] Where $r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}$ is the distance from point $(x, y)$ to source $i$.","title":"\ud83e\uddee Total Interference (Superposition Principle)"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-3-python-simulation-visualizing-interference","text":"import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude wavelength = 1.0 # Wavelength (meters) freq = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength omega = 2 * np.pi * freq def generate_polygon(n_sides, radius=2.0): angles = np.linspace(0, 2*np.pi, n_sides, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Polygon source points sources = generate_polygon(3) # Triangle # Time snapshot t = 0 eta_total = np.zeros_like(X) for (x_s, y_s) in sources: R = np.sqrt((X - x_s)**2 + (Y - y_s)**2) eta_total += A * np.cos(k * R - omega * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Wave Displacement') plt.title('Water Surface Interference Pattern (Equilateral Triangle Sources)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udc0d Task 3: Python Simulation \u2013 Visualizing Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-4-interpretation-and-applications","text":"","title":"\ud83e\udded Task 4: Interpretation and Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-analysis","text":"Constructive Interference : Peaks where wave crests meet Destructive Interference : Nulls where crest meets trough Fringe Patterns : Formed based on polygon geometry and wavelength","title":"\ud83d\udd0d Interference Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#applications","text":"Sound systems (phase control) Water wave tanks (research and education) Optics (laser interference from multiple slits) Antenna arrays","title":"\ud83c\udf10 Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83e\uddf2 Problem 5: Simulating the Effects of the Lorentz Force \ud83c\udfaf Task 1: Applications of the Lorentz Force \u26a1 Systems Where the Lorentz Force is Crucial Particle Accelerators : Control particle trajectories using magnetic and electric fields. Mass Spectrometers : Separate ions based on charge-to-mass ratio. Magnetic Confinement Fusion : Confine plasma using magnetic fields. Cathode Ray Tubes : Use electric and magnetic fields to deflect electron beams. \ud83e\udded Role of Fields Electric Fields ( \\(\\vec{E}\\) ) : Accelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) : Curve particle trajectories due to perpendicular force \\(\\vec{F} = q \\vec{v} \\times \\vec{B}\\) . \ud83e\uddee Task 2: Simulating Motion under Lorentz Force \ud83d\udd22 Equations of Motion Using Newton's second law: \\(m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\) \ud83d\udc0d Python Code: Particle Simulation in Uniform Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) B = np.array([0, 0, 1]) # Tesla E = np.array([0, 0, 0]) # V/m v0 = np.array([1e6, 0, 0]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) dt = 1e-11 steps = 5000 v = v0.copy() r = r0.copy() trajectory = [r.copy()] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory.append(r.copy()) trajectory = np.array(trajectory) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Trajectory of Charged Particle in Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.tight_layout() plt.show() \ud83d\udd0d Task 3: Parameter Exploration \ud83d\udd04 Modifiable Parameters Magnetic Field Strength ( \\(\\vec{B}\\) ) Electric Field Strength ( \\(\\vec{E}\\) ) Initial Velocity ( \\(\\vec{v}_0\\) ) Particle Charge ( \\(q\\) ) and Mass ( \\(m\\) ) \ud83d\udd04 Effects Observed Circular motion with \\(\\vec{B}\\) only. Helical motion with \\(\\vec{v}_z \\neq 0\\) . Drift motion when \\(\\vec{E} \\perp \\vec{B}\\) . \ud83d\udcca Task 4: Visualization of Results 2D/3D plots of trajectories reveal motion types. Larmor Radius : \\(r_L = \\frac{mv_\\perp}{qB}\\) Drift Velocity (for \\(\\vec{E} \\perp \\vec{B}\\) ): \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) \ud83e\udde0 Practical Context & Applications \u2699\ufe0f Real-World Systems Cyclotrons : Use \\(\\vec{B}\\) to spiral particles outward. Mass Spectrometers : Particle deflection radius reveals mass/charge. Magnetic Traps : Confine plasma in fusion experiments. \ud83d\ude80 Extensions and Improvements Include non-uniform magnetic fields . Add relativistic corrections at high speeds. Visualize multi-particle interactions or beam dynamics .","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-5-simulating-the-effects-of-the-lorentz-force","text":"","title":"\ud83e\uddf2 Problem 5: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-1-applications-of-the-lorentz-force","text":"","title":"\ud83c\udfaf Task 1: Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#systems-where-the-lorentz-force-is-crucial","text":"Particle Accelerators : Control particle trajectories using magnetic and electric fields. Mass Spectrometers : Separate ions based on charge-to-mass ratio. Magnetic Confinement Fusion : Confine plasma using magnetic fields. Cathode Ray Tubes : Use electric and magnetic fields to deflect electron beams.","title":"\u26a1 Systems Where the Lorentz Force is Crucial"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Electric Fields ( \\(\\vec{E}\\) ) : Accelerate particles linearly. Magnetic Fields ( \\(\\vec{B}\\) ) : Curve particle trajectories due to perpendicular force \\(\\vec{F} = q \\vec{v} \\times \\vec{B}\\) .","title":"\ud83e\udded Role of Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-2-simulating-motion-under-lorentz-force","text":"","title":"\ud83e\uddee Task 2: Simulating Motion under Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"Using Newton's second law: \\(m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\)","title":"\ud83d\udd22 Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-particle-simulation-in-uniform-fields","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # charge (C) m = 9.11e-31 # mass (kg) B = np.array([0, 0, 1]) # Tesla E = np.array([0, 0, 0]) # V/m v0 = np.array([1e6, 0, 0]) # initial velocity (m/s) r0 = np.array([0, 0, 0]) dt = 1e-11 steps = 5000 v = v0.copy() r = r0.copy() trajectory = [r.copy()] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory.append(r.copy()) trajectory = np.array(trajectory) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Trajectory of Charged Particle in Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python Code: Particle Simulation in Uniform Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-3-parameter-exploration","text":"","title":"\ud83d\udd0d Task 3: Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#modifiable-parameters","text":"Magnetic Field Strength ( \\(\\vec{B}\\) ) Electric Field Strength ( \\(\\vec{E}\\) ) Initial Velocity ( \\(\\vec{v}_0\\) ) Particle Charge ( \\(q\\) ) and Mass ( \\(m\\) )","title":"\ud83d\udd04 Modifiable Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#effects-observed","text":"Circular motion with \\(\\vec{B}\\) only. Helical motion with \\(\\vec{v}_z \\neq 0\\) . Drift motion when \\(\\vec{E} \\perp \\vec{B}\\) .","title":"\ud83d\udd04 Effects Observed"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-4-visualization-of-results","text":"2D/3D plots of trajectories reveal motion types. Larmor Radius : \\(r_L = \\frac{mv_\\perp}{qB}\\) Drift Velocity (for \\(\\vec{E} \\perp \\vec{B}\\) ): \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\)","title":"\ud83d\udcca Task 4: Visualization of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-context-applications","text":"","title":"\ud83e\udde0 Practical Context &amp; Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-systems","text":"Cyclotrons : Use \\(\\vec{B}\\) to spiral particles outward. Mass Spectrometers : Particle deflection radius reveals mass/charge. Magnetic Traps : Confine plasma in fusion experiments.","title":"\u2699\ufe0f Real-World Systems"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions-and-improvements","text":"Include non-uniform magnetic fields . Add relativistic corrections at high speeds. Visualize multi-particle interactions or beam dynamics .","title":"\ud83d\ude80 Extensions and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \ud83c\udf10 Problem 4: Equivalent Resistance Using Graph Theory \ud83c\udfaf Task 1: Algorithm Description for Equivalent Resistance Calculation \ud83d\udd0c Physical and Mathematical Meaning Electrical circuits can be represented as graphs: Nodes represent junctions or connection points. Edges represent resistors with weights as their resistance values. The goal is to reduce the entire graph to a single equivalent resistance between two specific terminals. \u2699\ufe0f Algorithm Description Input : Graph \\(G(V, E)\\) with edge weights as resistances. Loop : Detect series connections : A node connected to exactly two resistors and no external terminal \u2192 combine in series: \\(R_{eq} = R_1 + R_2\\) Detect parallel connections : Two nodes connected by multiple resistors \u2192 combine in parallel: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + ...\\) Reduce and update the graph. Repeat until graph reduces to one equivalent resistor between start and end nodes. \ud83d\udd04 Pseudocode function equivalent_resistance(graph, start, end): while graph has more than one edge between start and end: for node in graph: if node has degree 2 and not start or end: combine series resistors update graph for pairs of nodes: if multiple edges exist: combine in parallel update graph return weight of the single edge from start to end \ud83e\uddee Task 2: Full Python Implementation (Advanced) \ud83d\udce6 Libraries Used import networkx as nx \ud83d\udc0d Python Code: Graph Simplification Algorithm import networkx as nx def combine_series(graph): changed = False for node in list(graph.nodes): if graph.degree[node] == 2 and node not in ('A', 'B'): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: r1 = graph[node][neighbors[0]]['resistance'] r2 = graph[node][neighbors[1]]['resistance'] req = r1 + r2 graph.add_edge(neighbors[0], neighbors[1], resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel(graph): changed = False for u, v in list(graph.edges()): edges = list(graph.get_edge_data(u, v).values()) if len(edges) > 1: total_inv = sum(1.0 / e['resistance'] for e in edges) req = 1.0 / total_inv graph.remove_edges_from([(u, v)] * len(edges)) graph.add_edge(u, v, resistance=req) changed = True break return changed def simplify(graph, start='A', end='B'): while True: if not combine_series(graph) and not combine_parallel(graph): break return graph[start][end]['resistance'] # Example: Simple circuit G = nx.MultiGraph() G.add_edge('A', 'C', resistance=5) G.add_edge('C', 'B', resistance=10) G.add_edge('A', 'B', resistance=15) # Simplify to single resistance equivalent = simplify(G) print(f\"Equivalent Resistance between A and B: {equivalent:.2f} \u03a9\") \ud83d\udcca Task 3: Example Cases \u2705 Example 1: Series Resistors A \u2192 C (5\u03a9), C \u2192 B (10\u03a9) Equivalent: 15\u03a9 \u2705 Example 2: Parallel Resistors A \u2192 B (15\u03a9) and A \u2192 B (30\u03a9) Equivalent: \\(R = \\frac{1}{\\frac{1}{15} + \\frac{1}{30}} = 10\u03a9\\) \u2705 Example 3: Series + Parallel Mixed Combine series, then reduce in parallel \u2192 final single resistance \ud83e\udde0 Task 4: Algorithm Efficiency and Extensions \u23f1\ufe0f Efficiency Depends on the number of nodes/edges Reductions via series/parallel detection are fast (linear in size of graph) \ud83d\ude80 Improvements Use depth-first search (DFS) to identify subgraphs Implement Kirchhoff's laws with matrix methods for arbitrary topologies Extend for voltage/current analysis using Ohm\u2019s Law","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-4-equivalent-resistance-using-graph-theory","text":"","title":"\ud83c\udf10 Problem 4: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-1-algorithm-description-for-equivalent-resistance-calculation","text":"","title":"\ud83c\udfaf Task 1: Algorithm Description for Equivalent Resistance Calculation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#physical-and-mathematical-meaning","text":"Electrical circuits can be represented as graphs: Nodes represent junctions or connection points. Edges represent resistors with weights as their resistance values. The goal is to reduce the entire graph to a single equivalent resistance between two specific terminals.","title":"\ud83d\udd0c Physical and Mathematical Meaning"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"Input : Graph \\(G(V, E)\\) with edge weights as resistances. Loop : Detect series connections : A node connected to exactly two resistors and no external terminal \u2192 combine in series: \\(R_{eq} = R_1 + R_2\\) Detect parallel connections : Two nodes connected by multiple resistors \u2192 combine in parallel: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + ...\\) Reduce and update the graph. Repeat until graph reduces to one equivalent resistor between start and end nodes.","title":"\u2699\ufe0f Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function equivalent_resistance(graph, start, end): while graph has more than one edge between start and end: for node in graph: if node has degree 2 and not start or end: combine series resistors update graph for pairs of nodes: if multiple edges exist: combine in parallel update graph return weight of the single edge from start to end","title":"\ud83d\udd04 Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-2-full-python-implementation-advanced","text":"","title":"\ud83e\uddee Task 2: Full Python Implementation (Advanced)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#libraries-used","text":"import networkx as nx","title":"\ud83d\udce6 Libraries Used"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code-graph-simplification-algorithm","text":"import networkx as nx def combine_series(graph): changed = False for node in list(graph.nodes): if graph.degree[node] == 2 and node not in ('A', 'B'): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: r1 = graph[node][neighbors[0]]['resistance'] r2 = graph[node][neighbors[1]]['resistance'] req = r1 + r2 graph.add_edge(neighbors[0], neighbors[1], resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel(graph): changed = False for u, v in list(graph.edges()): edges = list(graph.get_edge_data(u, v).values()) if len(edges) > 1: total_inv = sum(1.0 / e['resistance'] for e in edges) req = 1.0 / total_inv graph.remove_edges_from([(u, v)] * len(edges)) graph.add_edge(u, v, resistance=req) changed = True break return changed def simplify(graph, start='A', end='B'): while True: if not combine_series(graph) and not combine_parallel(graph): break return graph[start][end]['resistance'] # Example: Simple circuit G = nx.MultiGraph() G.add_edge('A', 'C', resistance=5) G.add_edge('C', 'B', resistance=10) G.add_edge('A', 'B', resistance=15) # Simplify to single resistance equivalent = simplify(G) print(f\"Equivalent Resistance between A and B: {equivalent:.2f} \u03a9\")","title":"\ud83d\udc0d Python Code: Graph Simplification Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-3-example-cases","text":"","title":"\ud83d\udcca Task 3: Example Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series-resistors","text":"A \u2192 C (5\u03a9), C \u2192 B (10\u03a9) Equivalent: 15\u03a9","title":"\u2705 Example 1: Series Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-resistors","text":"A \u2192 B (15\u03a9) and A \u2192 B (30\u03a9) Equivalent: \\(R = \\frac{1}{\\frac{1}{15} + \\frac{1}{30}} = 10\u03a9\\)","title":"\u2705 Example 2: Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-series-parallel-mixed","text":"Combine series, then reduce in parallel \u2192 final single resistance","title":"\u2705 Example 3: Series + Parallel Mixed"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-4-algorithm-efficiency-and-extensions","text":"","title":"\ud83e\udde0 Task 4: Algorithm Efficiency and Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency","text":"Depends on the number of nodes/edges Reductions via series/parallel detection are fast (linear in size of graph)","title":"\u23f1\ufe0f Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#improvements","text":"Use depth-first search (DFS) to identify subgraphs Implement Kirchhoff's laws with matrix methods for arbitrary topologies Extend for voltage/current analysis using Ohm\u2019s Law","title":"\ud83d\ude80 Improvements"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcc8 Problem 5: Exploring the Central Limit Theorem through Simulations \ud83c\udfaf Task 1: Simulating Sampling Distributions \ud83d\udd22 Population Distributions We consider the following types of population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each case, we generate a large synthetic population. import numpy as np import matplotlib.pyplot as plt import seaborn as sns np.random.seed(0) n_population = 100000 uniform_pop = np.random.uniform(0, 1, n_population) exponential_pop = np.random.exponential(1, n_population) binomial_pop = np.random.binomial(10, 0.5, n_population) \ud83e\uddea Task 2: Sampling and Visualization We take samples of sizes [5, 10, 30, 50] and compute sample means repeatedly to build a distribution of sample means. def simulate_sampling(population, sample_sizes, n_trials=1000): results = {} for size in sample_sizes: means = [np.mean(np.random.choice(population, size)) for _ in range(n_trials)] results[size] = means return results sample_sizes = [5, 10, 30, 50] uniform_results = simulate_sampling(uniform_pop, sample_sizes) exponential_results = simulate_sampling(exponential_pop, sample_sizes) binomial_results = simulate_sampling(binomial_pop, sample_sizes) \ud83d\udcca Visualization def plot_sampling_distribution(results, dist_name): fig, axes = plt.subplots(1, 4, figsize=(20, 4)) for i, size in enumerate(sample_sizes): sns.histplot(results[size], kde=True, ax=axes[i], bins=30) axes[i].set_title(f\"{dist_name} (n={size})\") plt.suptitle(f\"Sampling Distribution of Sample Mean - {dist_name}\") plt.tight_layout() plt.show() plot_sampling_distribution(uniform_results, \"Uniform\") plot_sampling_distribution(exponential_results, \"Exponential\") plot_sampling_distribution(binomial_results, \"Binomial\") \ud83d\udd2c Task 3: Parameter Exploration As sample size increases, the distribution of sample means approaches a normal distribution , regardless of the original shape. The spread (variance) of the sample mean distribution decreases with larger sample sizes , reflecting \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) . \ud83c\udf0d Task 4: Practical Applications The CLT is used in numerous fields: Quality Control : Predicting defect rates from sample batches. Economics & Finance : Estimating population parameters like average income or stock returns. Social Sciences : Generalizing results from surveys. \u2705 Deliverables Summary \u2714\ufe0f Python simulation of sampling distributions. \u2714\ufe0f Histograms illustrating convergence to normality. \u2714\ufe0f Theoretical discussion and practical relevance of the CLT.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-5-exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcc8 Problem 5: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-1-simulating-sampling-distributions","text":"","title":"\ud83c\udfaf Task 1: Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions","text":"We consider the following types of population distributions: Uniform Distribution Exponential Distribution Binomial Distribution For each case, we generate a large synthetic population. import numpy as np import matplotlib.pyplot as plt import seaborn as sns np.random.seed(0) n_population = 100000 uniform_pop = np.random.uniform(0, 1, n_population) exponential_pop = np.random.exponential(1, n_population) binomial_pop = np.random.binomial(10, 0.5, n_population)","title":"\ud83d\udd22 Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-2-sampling-and-visualization","text":"We take samples of sizes [5, 10, 30, 50] and compute sample means repeatedly to build a distribution of sample means. def simulate_sampling(population, sample_sizes, n_trials=1000): results = {} for size in sample_sizes: means = [np.mean(np.random.choice(population, size)) for _ in range(n_trials)] results[size] = means return results sample_sizes = [5, 10, 30, 50] uniform_results = simulate_sampling(uniform_pop, sample_sizes) exponential_results = simulate_sampling(exponential_pop, sample_sizes) binomial_results = simulate_sampling(binomial_pop, sample_sizes)","title":"\ud83e\uddea Task 2: Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization","text":"def plot_sampling_distribution(results, dist_name): fig, axes = plt.subplots(1, 4, figsize=(20, 4)) for i, size in enumerate(sample_sizes): sns.histplot(results[size], kde=True, ax=axes[i], bins=30) axes[i].set_title(f\"{dist_name} (n={size})\") plt.suptitle(f\"Sampling Distribution of Sample Mean - {dist_name}\") plt.tight_layout() plt.show() plot_sampling_distribution(uniform_results, \"Uniform\") plot_sampling_distribution(exponential_results, \"Exponential\") plot_sampling_distribution(binomial_results, \"Binomial\")","title":"\ud83d\udcca Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-3-parameter-exploration","text":"As sample size increases, the distribution of sample means approaches a normal distribution , regardless of the original shape. The spread (variance) of the sample mean distribution decreases with larger sample sizes , reflecting \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) .","title":"\ud83d\udd2c Task 3: Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-4-practical-applications","text":"The CLT is used in numerous fields: Quality Control : Predicting defect rates from sample batches. Economics & Finance : Estimating population parameters like average income or stock returns. Social Sciences : Generalizing results from surveys.","title":"\ud83c\udf0d Task 4: Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables-summary","text":"\u2714\ufe0f Python simulation of sampling distributions. \u2714\ufe0f Histograms illustrating convergence to normality. \u2714\ufe0f Theoretical discussion and practical relevance of the CLT.","title":"\u2705 Deliverables Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory sdsdsd","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"sdsdsd","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}